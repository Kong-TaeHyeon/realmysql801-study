# 4장. 아키텍처

## 4.1 MySQL 엔진 아키텍처

### MySQL의 전체 구조

MySQL 서버는 크게 **MySQL 엔진**과 **스토리지 엔진**으로 구분할 수 있다.

1. **MySQL 엔진**  
   클라이언트로부터의 접속 및 쿼리 요청을 처리하는 **커넥션 핸들러**와 **SQL 파서 및 전처리기**, 쿼리의 최적화 실행을 위한 **옵티마이저**.
2. **스토리지 엔진**  
   실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담한다. **MySQL 서버에서 MySQL 엔진은 하나**지만 **스토리지 엔진은 여러 개를 동시에 사용**할 수 있다.

**핸들러 API**  
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러(Handler) 요청이라 하고, 여기서 사용되는 API를 핸들러 API라고 한다. -> 해당 핸들러 API를 통해 얼마나 많은 작업이 있었는지 확인할 수 있다. : `스토리지와 엔진 사이의 작업을 확인할 수 있음!`

### **MySQL 스레딩 구조**

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동한다. 크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있다.

**포그라운드 스레드(클라이언트 스레드)**
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청을 처리하는 쿼리 문장을 처리한다.

데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.

- MyISAM 테이블은 디스크 쓰기 작업 까지 일반적으로 포그라운드 스레드가 처리.
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리. 이후 버퍼에서 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

**백그라운드 스레드**

**InnoDB**는 다음과 같이 여러 가지 작업이 백그라운드로 처리된다.

- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

: `(쓰기 작업) 디스크 작업에 반영될 내용은 이미 클라이언트 스레드(버퍼풀)에 있기 때문에, 클라이언트 스레드가 처리할 필요가 없이, 백그라운드 스레드에게 위임하는 것인거였다!` => 책에서도 이와 같이 쓰기 작업(Insert, Update, Delete)'로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다고 언급하고 있음! vs. **MyISAM**

`참고로, 읽기 작업과는 분리해서 생각해야할 것 같다! => 캐시/버퍼에 존재하지 않다면 해당 데이터를 반드시 읽어온 후, 클라이언트 스레드가 해당 내용을 전달해야하기 때문에.`

### 메모리 할당 및 사용 구조

**글로벌 메모리 영역**

일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 단, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와는 무관하며, **모든 스레드에 의해 공유된다**.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

**로컬 메모리 영역**

로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며, 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다. : `절대 공유되지 않는다. 마치 Stack!`

- 정렬 버퍼(Sort buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 스토리지 엔진의 처리 영역

MyISAM 이나 InnoDB와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도 MySQL의 처리 내용은 동일하다. **단순히 데이터를 읽고/쓰는 단계에서 처리의 차이만 있을 뿐**이다. 실질적인 복잡한 처리는 MySQL 엔진의 처리 영역(쿼리 실행기)에서 처리된다.

이러한 스토리지 엔진을 **플러그인 아키텍처**를 통해, 다양한 스토리지 엔진을 적용할 수 있다. (테이블마다).

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인간 통신은 할 수 없음.
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음

- 상호 의존 관계를 설정할 수 없어서 초기화가 어려움.

### 쿼리 실행 구조

**쿼리 파서**  
쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해, **트리 형태의 구조**로 만들어 내는 작업을 통해 기본 문법 오류를 발견한다.

**전처리기**  
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. -> 각 토큰마다 테이블 이름, 컬럼 이름, 내장 함수와 같은 개체 매핑.

**옵티마이저**  
사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당. : `성능 개선 포인트!`

**실행 엔진**  
실행 엔즌은 만들어진 **계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력**으로 연결하는 역할

**핸들러**  
실행 엔진의 요청을 따라 데이터를 디스크로 저장하고, 디스크로부터 읽어 오는 역할을 담당한다. -> 핸들러는 결국 스토리지 엔진을 의미하게 된다.

## 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다. `: 즉, 행 단위 잠금을 통해 동일 테이블에 대해서도 동시성 처리를 하면서도, 높은 속도를 제공할 수 있는거였다.`

### 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다. : `즉, 세컨더리 인덱스를 통해 접근하더라도 결국 프라이머리 키를 거치게 되는것 (이중 접근)`

### 외래 키 지원

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM 이나 MEMORY 테이블에서는 사용할 수 없다.

- 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고
- 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요

결국, 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 주의가 필요하다.

### MVCC(Multi Version Concurrency Control)

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다. InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.

- **Multi Version** : 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다.

`INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울'); `  
`COMMIT;`

InnoDB 버퍼 풀(Global Memory)과 디스크에 저장된다.

`UPDATE member SET m_area='경기' WHERE m_id=12;`

UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값인 '경기'로 업데이트된다.

- 디스크는 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐수도 있음.
- Undo log에는 변경전 값인 '서울'이 아이디와 함께 복사된다.

`아직 COMMIT / ROLLBACK이 발생하지 않은 상태에서 다른 사용자가 m_id=12인 레코드를 조회하면 어디를 조회할까?`

격리 수준이 `READ_UNCOMMITTED`인 경우에는 **InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환**한다.

그 이상의 격리 수준인 경우에는 아직 커밋되지 않았기 때문에 이전 데이터 (언두 영역)를 반환한다.

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

격리 수준이 `SERIALIZABLE`이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 수준인 경우 INSERT와 연결되지 않은 **순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행**된다.

- 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

오랜 시간 동안 활성 상태인 트랜잭션이 있는 경우, 해당 트랜잭션으로부터 발생한 언두 로그를 일관된 읽기를 위해 게속 유지하고 있어야 한다. 이로인해 성능 저하의 원인이 될 수 있다. : `트랜잭션의 작업 단위를 최대한 줄이는게 좋겠군!`
