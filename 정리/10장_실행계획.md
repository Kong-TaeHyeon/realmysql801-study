# 10장. 실행 계획

대부분의 DBMS는 많은 데이터를 안전하게 저장 및 관리하고 사용자가 원하는 데이터를 **빠르게** 조회할 수 있게 해주는 것이 주목적이다. 이러한 목적을 달성하려면 옵티마이저가 사용자의 쿼리를 최적으로 처리될 수 있게 하는 쿼리의 실행 계획을 수립할 수 있어야 한다.

하지만 옵티마이저가 관리자나 사용자의 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있는 것은 아니다. DBMS 서버는 이러한 문제점을 관리자나 사용자가 보완할 수 있도록 `EXPLAIN` 명령으로 옵티마이저가 수립한 실행 계획을 확인할 수 있게 해준다.

## 통계 정보

MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
: `테이블 칼럼의 값들의 분포에 대한 정보가 없기 때문에 실행 계획에 대한 정확도가 떨어짐!`

### 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보이다. 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다. 예를 들어, 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 레코드가 10건 미만인 것처럼 돼 있다면 옵티마이저는 인덱스 레인지 스캔이 아닌, 풀 테이블 스캔으로 실행해 버릴 수도 있다. : `왜냐면, 인덱스를 읽어온 뒤 다시 테이블을 읽는 것보다, 한번에 테이블에서 데이터를 가져올 수 있다고 생각하므로!`

MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용하지만, 다른 DBMS보다 통계 정확도가 높지 않고, 휘발성이 강했다. 그래서 MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다. : `실제 데이터를 분석하는데에 오버헤드가 있을 것 같은데..!`

#### MySQL 서버의 통계 정보

MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다. : `이전 버전에서는 메모리에 통계 정보를 수집해왔다고 한다. (휘발성)`

MySQL 5.6 버전부터는 각 테이블의 통계 정보를 테이블로 관리할 수 있게 개선되었다. : `innodb_index_stats` , `innodb_table_stats`

MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에만 저장되며, MySQL 서버가 재시작되면 통계 정보가 초기화됐다. 그래서 MySQL 서버가 시작되면 모든 테이블의 통계 정보는 다시 수집돼야 했다.

영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보를 수집할 수도 있다. 물론 더 정확한 통계 정보 수집에는 많은 시간이 소요되겠지만, 이 **통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 시간을 투자할 충분한 가치가 있는 것**이다.

### 히스토그램

MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. : `이를 보완하기 위해, 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용!`

8.0 버전으로 업그레이드되면서 MySQL 서버도 드디어 **칼럼의 데이터 분포도**를 참조할 수 있는 히스토그램(Histogram) 정보를 활용할 수 있게 됐다.

#### 히스토그램 정보 수집 및 삭제

MySQL 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 수동으로 수집 및 관리된다.

```sql
-- 히스토그램 정보 수집
ANALYZE TABLE employees.employees
UPDATE HISTOGRAM ON gender, hire_date;

-- 조회
SELECT *
FROM COLUMN_STATISTICS
WHERE SCHEMA_NAME = 'employees' AND TABLE_NAME = 'employees'
```

**히스토그램 타입 종류**

- **싱글톤 히스토그램** : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고 불린다.
- **높이 균형 히스토그램** : 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고도 불린다. : 기울기가 일정하다는 것의 의미는 데이터가 고른 범위에 분포되어있다는 의미이다.

#### 히스토그램 용도

MySQL 서버에 히스토그램이 도입되기 이전에도 테이블과 인덱스에 대한 통계 정보는 존재했다. 하지만 기존 MySQL 서버가 가지고 있던 통계 정보는 **테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수** 정도이다.

Ex. 테이블의 레코드가 1000건이고, 유니크한 값 개수가 100개 였다면, MySQL 서버는 이 칼럼에 대해 다음과 같은 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측한다. : `그렇다면, 데이터가 충분히 많으니 인덱스를 타고 검색을 했겠지?`

히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측하지만, 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다. : `이는 조인과 같이 기준이 되는 테이블을 선택할 때, 큰 도움을 줄 것으로 생각된다!`

#### 히스토그램과 인덱스

히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느 정도 공통점을 가진다고 볼 수 있다.

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 이때 **조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링**해서 살펴본다. 이 작업을 메뉴얼에서는 `인덱스 다이브(Index Dive)`라고 표현한다.

```sql
SELECT *
FROM employees
WHERE first_name = 'Tonny'
AND birth_date BETWEEN '1954-01-01' AND '1995-01-01';
```

first_name 컬럼에만 인덱스가 생성되고, 히스토그램이 존재하는 경우, 옵티마이저는 first_name 히스토그램을 이용하게 될까? : `정확성 측면에서, **실제 인덱스 다이브를 통해 직접 수집한 정보**를 이용한다!`

- 조건에 여러 인덱스들을 조회해야 하는 경우, 인덱스 다이브 비용은 그만큼 커지게 된다.

따라서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

### 코스트 모델(Cost Model)

MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.

- 디스크로부터 데이터 페이지 읽기.
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기.
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

이전에는 각 작업에 대한 비용 상수가 고정되어 있었다면, 현재는 DBMS 관리자가 조정할 수 있게 되었다. 또한 칼럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고, 이를 실행 계획에 사용되기 시작했다.
: `특정 인덱스의 메모리에 적재된 페이지의 비율이 적다면, 그만큼 I/O 작업이 늘어나기 때문에 높은 비용으로 측정될 듯!`

## 실행 계획 확인

MySQL 서버의 실행 계획은 `DESC` 또는 `EXPLAIN` 명령으로 확인할 수 있다. 그리고 MySQL 8.0 버전부터는 `EXPLAIN` 명령에 사용할 수 있는 새로운 옵션이 추가되었다.

### 쿼리의 실행 시간 확인

MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가되었다. : 항상 결과를 TREE 포멧으로 보여준다.

`EXPLAIN ANALYZE` 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 것이다. : `따라서, 쿼리의 실행 시간이 아주 오래 걸린다면 먼저 EXPLAIN 명령으로 먼저 실행 계획만 확인한 후 튜닝을 진행한 뒤 확인하도록 하자!`

## 실행 계획 분석

### id 칼럼

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. **하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만, 같은 id 값이 부여**된다.

반대로 아래와 같은 쿼리에서는 각기 다른 id 값을 지닌다.

```sql
SELECT
    ((SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments)) AS total_count;
```

**하지만, 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다!**

![id칼럼과 순서](/이미지/image13.png)

해당 쿼리의 실행 순서는 employees 테이블을 먼저 읽고, 그 결과를 이용해 dept_emp 테이블을 읽는 순서로 실행된 것이다. : `EXPLAIN FORMAT=TREE 명령으로 확인하면 순서를 더 명확히 알 수 있다.`

### select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. select_type 칼럼에 표시될 수 있는 값은 다음과 같다.

#### SIMPLE

UNION이나 서브쿼리를 사용하지 않는 조인을 포함한 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 select_type은 SIMPLE로 표시된다. 쿼리 문장이 아무리 복잡하더라도 **실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 하나만 존재**한다. 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 `SIMPLE`로 표시된다.

#### PRIMARY

UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리는 select_type이 PRIMARY로 표시된다. SIMPLE과 마찬가지로 **select_type이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재**하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 `PRIMARY`로 표시된다.

#### UNION

UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type은 `UNION으로` 표시된다. UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION 되는 쿼리들을 모아서 저장하는 임시 테이블(`DERIVED`)이 select_type으로 표시된다.

#### DEPENDENT UNION

DEPENDENT UNION 또한 UNION 이나 UNION ALL로 집합을 결정하는 쿼리에 표시된다. 그리고 여기서 DEPENDENT는 외부 쿼리에 의해 영향을 받은 것을 의미한다.

```sql
EXPLAIN
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
    SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
    UNION
    SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

해당 쿼리의 경우 옵티마이저가 employees 테이블을 먼저 읽은 다음 서브 쿼리를 실행하는데, 이때 employees 테이블의 컬럼 값이 서브 쿼리에 영향을 준다.
내부적으로는 `e2.emp_no=e1.emp_no` 와 `e3.emp_no = e1.emp_no` 조건이 자동으로 추가되어 실행되기 때문이다.

#### UNION RESULT

UNION RESULT는 `UNION` 결과를 담아두는 테이블을 의미한다. UNION ALL의 경우에는 임시 테이블을 사용하지 않는다. : `UNION, UNION DISTINCT 의 경우, 임시 테이블로 생성.`

#### SUBQUERY

일반적으로 서브쿼리라고 하면 여러 가지를 통틀어서 이야기할 때가 많은데, `select_type`의 SUBQUERY는 FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.

#### DEPENDENT SUBQUERY

서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 칼럼을 사용하는 경우, `select_type`에 DEPENDENT SUBQUERY라고 표시된다.

```sql
SELECT e.first_name
    (SELECT COUNT(*)
    FROM dept_emp de, dept manager dm
    WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no) AS cnt
FROM employees e
WHERE e.first_name = 'Matt';
```

이 경우에는 안쪽(Inner)의 서브쿼리 결과가 바깥쪽(Outer) SELECT 쿼리의 결과에 의존적이기 때문에 DEPENDENT 키워드가 붙는다. : `외부 쿼리가 먼저 실행된 후, 내부 쿼리가 실행되어야 하므로 일반 서브쿼리보다 처리 속도가 느릴 때가 많다!`

#### DERIVED

DERIVED는 단위 SELECT 쿼리의 실행 결과로 **메모리나 디스크에 임시 테이블**을 생성하는 것을 의미한다. : `조인으로 해결할 수 있다면, 조인을 통해 임시 테이블을 생성하는 것을 지양하자. (For 인덱스, I/O 작업 최소화)`

### table 칼럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. table 칼럼에 `<derived N> 또는 <union M, N>`으로 둘러싸인 이름이 명시되는 경우가 많은데, 이 테이블은 임시 테이블을 의미한다. 또한 <> 항상 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭한다.

![derived N의 의미](/이미지/image14.png)

1. 첫 번째 라인 테이블이 `<derived2>` 이므로, id =2인 단위 쿼리가 먼저 실행될 것이다. 그리고 그 결과가 파생 테이블로 주어진다.
2. 세 번째 라인을 보면, select_type 이 derived로 표시돼 있다. 즉 이 라인은 table 칼럼에 표시된 dept_emp 테이블을 읽어서 파생 테이블을 생성한다는 것을 알 수 있다.
3. 첫 번째 라인과 두 번째 라인은 같은 id 값을 가지고 있는 것으로 봐서 2개 테이블이 조인되는 쿼리라는 것을 알 수 있다. 이때, e 테이블보다 `<derived 2>`이 먼저 표시됐기 때문에, 해당 테이블이 드라이빙 테이블이 된다는 것을 알 수 있다.

### type 칼럼

쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다. 여기서 방식이라 함은 인덱스를 사용해 레코드를 읽었는지, 아니면 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 레코드를 읽었는지를 의미한다. : `쿼리 튜닝 시 반드시 체크!`

#### const

테이블의 레코드 건수와 관계없이 쿼리가 **프라이머리 키나 유니크 키 컬럼을 이용하는** WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const라고 한다.

#### eq_ref

eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다. 조인에서 처음 읽은 테이블의 칼럼값을, **그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때**를 가리켜 eq_ref라고 한다. 즉, 조인에서 조인 대상의 테이블의 행이 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.

```sql
SELECT * FROM dept_emp de, employees e
WHERE e.emp_no = de.emp_no AND de.dept_no = 'd005';
```

![eq_ref](/이미지/image15.png)

1. 먼저 de 를 읽는다. (de.dept_no = 'd005')
2. 이후, de.emp_no 와 일치하는 e.emp_no 를 불러온다. (e 의 프라이머리 키)

#### ref

ref 접근 방법은 eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다. : `반환되는 레코드가 반드시 1건이라는 보장이 없다!`

#### fulltext

fulltext 접근 방법은 MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.

```sql
CREATE TABLE employee_name(
    emp_no int NOT NULL,
    first_name varchar(14) NOT NULL,
    last_name varchar(16) NOT NULL,
    primary key (emp_no),
    fulltext key fx_name (first_name, first_name) WITH PARSER ngram
)
```

```sql
SELECT *
FROM employee_name
WHERE emp_no = 10001
    AND emp_no BETWEEN 1001 AND 10005
    AND MATCH(first_name, last_name) AGAINST('Facello', IN BOOLEAN MODE)
```

이 경우, 프라이머리 키 1건만 선택하면 되므로 `type=const` 이다.

```sql
SELECT *
FROM employee_name
WHERE
    emp_no BETWEEN 1001 AND 10005
    AND MATCH(first_name, last_name) AGAINST('Facello', IN BOOLEAN MODE)
```

이 경우에는 옵티마이저가 전문 검색 조건을 선택하였다. : `하지만 실제로는 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 많다고 한다!`

#### ref_or_null

이 접근 방법은 ref 접근 방법과 같은데, NULL 비교가 추가된 형태다.

#### unique_subquery

WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다. unique_subquery의 의미 그대로 **서브 쿼리에서 중복되지 않는 유니크한 값만 반환**할 때 이 접근 방법을 사용한다.

#### index_subquery

IN(subquery)에서 subquery가 중복된 값을 반환할 수도 있는 경우, 서브쿼리 결과의 중복된 값을 인덱스를 통해 제거할 수 있을때.

#### range

range는 우리가 익히 알고 있는 인덱스 레인지 스캔 형태의 접근 방법이다. range는 인덱스를 하나의 값이아니라 범위로 검색하는 경우를 의미한다. : `range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.`

#### index_merge

지금까지 설명한 다른 접근 방법과는 달리 index_merge 접근 방법은 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.

```sql
SELECT *
FROM employees
WHERE emp_no BETWEEN 10001 AND 11000
    OR first_name='Smith'
```

이 경우 각각의 인덱스(emp_no, first_name)에 대해서 **최적의 쿼리를 수행 후 결과를 병합**하기 때문에 index_merge 라는 typ e으로 표시된다.
: `여러 인덱스를 읽고, 병합하는 과정이 있기 떄문에 크게 효율적이지 않다고 한다!`

#### index

index 접근 방법은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다. range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것이 아니다.

index 접근 방법은 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다. 하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작다.

![index 접근 방법](/이미지/image16.png)
