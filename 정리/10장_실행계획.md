# 10장. 실행 계획

대부분의 DBMS는 많은 데이터를 안전하게 저장 및 관리하고 사용자가 원하는 데이터를 **빠르게** 조회할 수 있게 해주는 것이 주목적이다. 이러한 목적을 달성하려면 옵티마이저가 사용자의 쿼리를 최적으로 처리될 수 있게 하는 쿼리의 실행 계획을 수립할 수 있어야 한다.

하지만 옵티마이저가 관리자나 사용자의 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있는 것은 아니다. DBMS 서버는 이러한 문제점을 관리자나 사용자가 보완할 수 있도록 `EXPLAIN` 명령으로 옵티마이저가 수립한 실행 계획을 확인할 수 있게 해준다.

## 통계 정보

MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
: `테이블 칼럼의 값들의 분포에 대한 정보가 없기 때문에 실행 계획에 대한 정확도가 떨어짐!`

### 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보이다. 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다. 예를 들어, 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 레코드가 10건 미만인 것처럼 돼 있다면 옵티마이저는 인덱스 레인지 스캔이 아닌, 풀 테이블 스캔으로 실행해 버릴 수도 있다. : `왜냐면, 인덱스를 읽어온 뒤 다시 테이블을 읽는 것보다, 한번에 테이블에서 데이터를 가져올 수 있다고 생각하므로!`

MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용하지만, 다른 DBMS보다 통계 정확도가 높지 않고, 휘발성이 강했다. 그래서 MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다. : `실제 데이터를 분석하는데에 오버헤드가 있을 것 같은데..!`

#### MySQL 서버의 통계 정보

MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다. : `이전 버전에서는 메모리에 통계 정보를 수집해왔다고 한다. (휘발성)`

MySQL 5.6 버전부터는 각 테이블의 통계 정보를 테이블로 관리할 수 있게 개선되었다. : `innodb_index_stats` , `innodb_table_stats`

MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에만 저장되며, MySQL 서버가 재시작되면 통계 정보가 초기화됐다. 그래서 MySQL 서버가 시작되면 모든 테이블의 통계 정보는 다시 수집돼야 했다.

영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보를 수집할 수도 있다. 물론 더 정확한 통계 정보 수집에는 많은 시간이 소요되겠지만, 이 **통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 시간을 투자할 충분한 가치가 있는 것**이다.

### 히스토그램

MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. : `이를 보완하기 위해, 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용!`

8.0 버전으로 업그레이드되면서 MySQL 서버도 드디어 **칼럼의 데이터 분포도**를 참조할 수 있는 히스토그램(Histogram) 정보를 활용할 수 있게 됐다.

#### 히스토그램 정보 수집 및 삭제

MySQL 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 수동으로 수집 및 관리된다.

```sql
-- 히스토그램 정보 수집
ANALYZE TABLE employees.employees
UPDATE HISTOGRAM ON gender, hire_date;

-- 조회
SELECT *
FROM COLUMN_STATISTICS
WHERE SCHEMA_NAME = 'employees' AND TABLE_NAME = 'employees'
```

**히스토그램 타입 종류**

- **싱글톤 히스토그램** : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고 불린다.
- **높이 균형 히스토그램** : 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고도 불린다. : 기울기가 일정하다는 것의 의미는 데이터가 고른 범위에 분포되어있다는 의미이다.

#### 히스토그램 용도

MySQL 서버에 히스토그램이 도입되기 이전에도 테이블과 인덱스에 대한 통계 정보는 존재했다. 하지만 기존 MySQL 서버가 가지고 있던 통계 정보는 **테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수** 정도이다.

Ex. 테이블의 레코드가 1000건이고, 유니크한 값 개수가 100개 였다면, MySQL 서버는 이 칼럼에 대해 다음과 같은 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측한다. : `그렇다면, 데이터가 충분히 많으니 인덱스를 타고 검색을 했겠지?`

히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측하지만, 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다. : `이는 조인과 같이 기준이 되는 테이블을 선택할 때, 큰 도움을 줄 것으로 생각된다!`

#### 히스토그램과 인덱스

히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느 정도 공통점을 가진다고 볼 수 있다.

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 이때 **조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링**해서 살펴본다. 이 작업을 메뉴얼에서는 `인덱스 다이브(Index Dive)`라고 표현한다.

```sql
SELECT *
FROM employees
WHERE first_name = 'Tonny'
AND birth_date BETWEEN '1954-01-01' AND '1995-01-01';
```

first_name 컬럼에만 인덱스가 생성되고, 히스토그램이 존재하는 경우, 옵티마이저는 first_name 히스토그램을 이용하게 될까? : `정확성 측면에서, **실제 인덱스 다이브를 통해 직접 수집한 정보**를 이용한다!`

- 조건에 여러 인덱스들을 조회해야 하는 경우, 인덱스 다이브 비용은 그만큼 커지게 된다.

따라서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

### 코스트 모델(Cost Model)

MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.

- 디스크로부터 데이터 페이지 읽기.
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기.
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

이전에는 각 작업에 대한 비용 상수가 고정되어 있었다면, 현재는 DBMS 관리자가 조정할 수 있게 되었다. 또한 칼럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고, 이를 실행 계획에 사용되기 시작했다.
: `특정 인덱스의 메모리에 적재된 페이지의 비율이 적다면, 그만큼 I/O 작업이 늘어나기 때문에 높은 비용으로 측정될 듯!`

## 실행 계획 확인

MySQL 서버의 실행 계획은 `DESC` 또는 `EXPLAIN` 명령으로 확인할 수 있다. 그리고 MySQL 8.0 버전부터는 `EXPLAIN` 명령에 사용할 수 있는 새로운 옵션이 추가되었다.

### 쿼리의 실행 시간 확인

MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가되었다. : 항상 결과를 TREE 포멧으로 보여준다.

`EXPLAIN ANALYZE` 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 것이다. : `따라서, 쿼리의 실행 시간이 아주 오래 걸린다면 먼저 EXPLAIN 명령으로 먼저 실행 계획만 확인한 후 튜닝을 진행한 뒤 확인하도록 하자!`

## 실행 계획 분석

### id 칼럼

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. **하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만, 같은 id 값이 부여**된다.

반대로 아래와 같은 쿼리에서는 각기 다른 id 값을 지닌다.

```sql
SELECT
    ((SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments)) AS total_count;
```

**하지만, 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다!**

![id칼럼과 순서](/이미지/image13.png)

해당 쿼리의 실행 순서는 employees 테이블을 먼저 읽고, 그 결과를 이용해 dept_emp 테이블을 읽는 순서로 실행된 것이다. : `EXPLAIN FORMAT=TREE 명령으로 확인하면 순서를 더 명확히 알 수 있다.`

### select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. select_type 칼럼에 표시될 수 있는 값은 다음과 같다.

#### SIMPLE

UNION이나 서브쿼리를 사용하지 않는 조인을 포함한 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 select_type은 SIMPLE로 표시된다. 쿼리 문장이 아무리 복잡하더라도 **실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 하나만 존재**한다. 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 `SIMPLE`로 표시된다.

#### PRIMARY

UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리는 select_type이 PRIMARY로 표시된다. SIMPLE과 마찬가지로 **select_type이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재**하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 `PRIMARY`로 표시된다.

#### UNION

UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type은 `UNION으로` 표시된다. UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION 되는 쿼리들을 모아서 저장하는 임시 테이블(`DERIVED`)이 select_type으로 표시된다.

#### DEPENDENT UNION

DEPENDENT UNION 또한 UNION 이나 UNION ALL로 집합을 결정하는 쿼리에 표시된다. 그리고 여기서 DEPENDENT는 외부 쿼리에 의해 영향을 받은 것을 의미한다.

```sql
EXPLAIN
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
    SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
    UNION
    SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

해당 쿼리의 경우 옵티마이저가 employees 테이블을 먼저 읽은 다음 서브 쿼리를 실행하는데, 이때 employees 테이블의 컬럼 값이 서브 쿼리에 영향을 준다.
내부적으로는 `e2.emp_no=e1.emp_no` 와 `e3.emp_no = e1.emp_no` 조건이 자동으로 추가되어 실행되기 때문이다.
