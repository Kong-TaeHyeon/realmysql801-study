# 10장. 실행 계획

대부분의 DBMS는 많은 데이터를 안전하게 저장 및 관리하고 사용자가 원하는 데이터를 **빠르게** 조회할 수 있게 해주는 것이 주목적이다. 이러한 목적을 달성하려면 옵티마이저가 사용자의 쿼리를 최적으로 처리될 수 있게 하는 쿼리의 실행 계획을 수립할 수 있어야 한다.

하지만 옵티마이저가 관리자나 사용자의 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있는 것은 아니다. DBMS 서버는 이러한 문제점을 관리자나 사용자가 보완할 수 있도록 `EXPLAIN` 명령으로 옵티마이저가 수립한 실행 계획을 확인할 수 있게 해준다.

## 통계 정보

MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
: `테이블 칼럼의 값들의 분포에 대한 정보가 없기 때문에 실행 계획에 대한 정확도가 떨어짐!`

### 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보이다. 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다. 예를 들어, 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 레코드가 10건 미만인 것처럼 돼 있다면 옵티마이저는 인덱스 레인지 스캔이 아닌, 풀 테이블 스캔으로 실행해 버릴 수도 있다. : `왜냐면, 인덱스를 읽어온 뒤 다시 테이블을 읽는 것보다, 한번에 테이블에서 데이터를 가져올 수 있다고 생각하므로!`

MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용하지만, 다른 DBMS보다 통계 정확도가 높지 않고, 휘발성이 강했다. 그래서 MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다. : `실제 데이터를 분석하는데에 오버헤드가 있을 것 같은데..!`

#### MySQL 서버의 통계 정보

MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다. : `이전 버전에서는 메모리에 통계 정보를 수집해왔다고 한다. (휘발성)`

MySQL 5.6 버전부터는 각 테이블의 통계 정보를 테이블로 관리할 수 있게 개선되었다. : `innodb_index_stats` , `innodb_table_stats`

MySQL 5.5 버전까지는 테이블의 통계 정보가 메모리에만 저장되며, MySQL 서버가 재시작되면 통계 정보가 초기화됐다. 그래서 MySQL 서버가 시작되면 모든 테이블의 통계 정보는 다시 수집돼야 했다.

영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보를 수집할 수도 있다. 물론 더 정확한 통계 정보 수집에는 많은 시간이 소요되겠지만, 이 **통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 시간을 투자할 충분한 가치가 있는 것**이다.

### 히스토그램

MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. : `이를 보완하기 위해, 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용!`

8.0 버전으로 업그레이드되면서 MySQL 서버도 드디어 **칼럼의 데이터 분포도**를 참조할 수 있는 히스토그램(Histogram) 정보를 활용할 수 있게 됐다.

#### 히스토그램 정보 수집 및 삭제

MySQL 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 수동으로 수집 및 관리된다.

```sql
-- 히스토그램 정보 수집
ANALYZE TABLE employees.employees
UPDATE HISTOGRAM ON gender, hire_date;

-- 조회
SELECT *
FROM COLUMN_STATISTICS
WHERE SCHEMA_NAME = 'employees' AND TABLE_NAME = 'employees'
```

**히스토그램 타입 종류**

- **싱글톤 히스토그램** : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고 불린다.
- **높이 균형 히스토그램** : 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고도 불린다. : 기울기가 일정하다는 것의 의미는 데이터가 고른 범위에 분포되어있다는 의미이다.

#### 히스토그램 용도

MySQL 서버에 히스토그램이 도입되기 이전에도 테이블과 인덱스에 대한 통계 정보는 존재했다. 하지만 기존 MySQL 서버가 가지고 있던 통계 정보는 **테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수** 정도이다.

Ex. 테이블의 레코드가 1000건이고, 유니크한 값 개수가 100개 였다면, MySQL 서버는 이 칼럼에 대해 다음과 같은 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측한다. : `그렇다면, 데이터가 충분히 많으니 인덱스를 타고 검색을 했겠지?`

히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측하지만, 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다. : `이는 조인과 같이 기준이 되는 테이블을 선택할 때, 큰 도움을 줄 것으로 생각된다!`

#### 히스토그램과 인덱스

히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느 정도 공통점을 가진다고 볼 수 있다.

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 이때 **조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링**해서 살펴본다. 이 작업을 메뉴얼에서는 `인덱스 다이브(Index Dive)`라고 표현한다.

```sql
SELECT *
FROM employees
WHERE first_name = 'Tonny'
AND birth_date BETWEEN '1954-01-01' AND '1995-01-01';
```

first_name 컬럼에만 인덱스가 생성되고, 히스토그램이 존재하는 경우, 옵티마이저는 first_name 히스토그램을 이용하게 될까? : `정확성 측면에서, **실제 인덱스 다이브를 통해 직접 수집한 정보**를 이용한다!`

- 조건에 여러 인덱스들을 조회해야 하는 경우, 인덱스 다이브 비용은 그만큼 커지게 된다.

따라서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

### 코스트 모델(Cost Model)

MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.

- 디스크로부터 데이터 페이지 읽기.
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기.
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

이전에는 각 작업에 대한 비용 상수가 고정되어 있었다면, 현재는 DBMS 관리자가 조정할 수 있게 되었다. 또한 칼럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고, 이를 실행 계획에 사용되기 시작했다.
: `특정 인덱스의 메모리에 적재된 페이지의 비율이 적다면, 그만큼 I/O 작업이 늘어나기 때문에 높은 비용으로 측정될 듯!`

## 실행 계획 확인

MySQL 서버의 실행 계획은 `DESC` 또는 `EXPLAIN` 명령으로 확인할 수 있다. 그리고 MySQL 8.0 버전부터는 `EXPLAIN` 명령에 사용할 수 있는 새로운 옵션이 추가되었다.

### 쿼리의 실행 시간 확인

MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가되었다. : 항상 결과를 TREE 포멧으로 보여준다.

`EXPLAIN ANALYZE` 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 것이다. : `따라서, 쿼리의 실행 시간이 아주 오래 걸린다면 먼저 EXPLAIN 명령으로 먼저 실행 계획만 확인한 후 튜닝을 진행한 뒤 확인하도록 하자!`

## 실행 계획 분석

### id 칼럼

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. **하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만, 같은 id 값이 부여**된다.

반대로 아래와 같은 쿼리에서는 각기 다른 id 값을 지닌다.

```sql
SELECT
    ((SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments)) AS total_count;
```

**하지만, 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다!**

![id칼럼과 순서](/이미지/image13.png)

해당 쿼리의 실행 순서는 employees 테이블을 먼저 읽고, 그 결과를 이용해 dept_emp 테이블을 읽는 순서로 실행된 것이다. : `EXPLAIN FORMAT=TREE 명령으로 확인하면 순서를 더 명확히 알 수 있다.`

### select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. select_type 칼럼에 표시될 수 있는 값은 다음과 같다.

#### SIMPLE

UNION이나 서브쿼리를 사용하지 않는 조인을 포함한 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 select_type은 SIMPLE로 표시된다. 쿼리 문장이 아무리 복잡하더라도 **실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 하나만 존재**한다. 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 `SIMPLE`로 표시된다.

#### PRIMARY

UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리는 select_type이 PRIMARY로 표시된다. SIMPLE과 마찬가지로 **select_type이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재**하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 `PRIMARY`로 표시된다.

#### UNION

UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type은 `UNION으로` 표시된다. UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION 되는 쿼리들을 모아서 저장하는 임시 테이블(`DERIVED`)이 select_type으로 표시된다.

#### DEPENDENT UNION

DEPENDENT UNION 또한 UNION 이나 UNION ALL로 집합을 결정하는 쿼리에 표시된다. 그리고 여기서 DEPENDENT는 외부 쿼리에 의해 영향을 받은 것을 의미한다.

```sql
EXPLAIN
SELECT *
FROM employees e1 WHERE e1.emp_no IN (
    SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
    UNION
    SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
);
```

해당 쿼리의 경우 옵티마이저가 employees 테이블을 먼저 읽은 다음 서브 쿼리를 실행하는데, 이때 employees 테이블의 컬럼 값이 서브 쿼리에 영향을 준다.
내부적으로는 `e2.emp_no=e1.emp_no` 와 `e3.emp_no = e1.emp_no` 조건이 자동으로 추가되어 실행되기 때문이다.

#### UNION RESULT

UNION RESULT는 `UNION` 결과를 담아두는 테이블을 의미한다. UNION ALL의 경우에는 임시 테이블을 사용하지 않는다. : `UNION, UNION DISTINCT 의 경우, 임시 테이블로 생성.`

#### SUBQUERY

일반적으로 서브쿼리라고 하면 여러 가지를 통틀어서 이야기할 때가 많은데, `select_type`의 SUBQUERY는 FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.

#### DEPENDENT SUBQUERY

서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 칼럼을 사용하는 경우, `select_type`에 DEPENDENT SUBQUERY라고 표시된다.

```sql
SELECT e.first_name
    (SELECT COUNT(*)
    FROM dept_emp de, dept manager dm
    WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no) AS cnt
FROM employees e
WHERE e.first_name = 'Matt';
```

이 경우에는 안쪽(Inner)의 서브쿼리 결과가 바깥쪽(Outer) SELECT 쿼리의 결과에 의존적이기 때문에 DEPENDENT 키워드가 붙는다. : `외부 쿼리가 먼저 실행된 후, 내부 쿼리가 실행되어야 하므로 일반 서브쿼리보다 처리 속도가 느릴 때가 많다!`

#### DERIVED

DERIVED는 단위 SELECT 쿼리의 실행 결과로 **메모리나 디스크에 임시 테이블**을 생성하는 것을 의미한다. : `조인으로 해결할 수 있다면, 조인을 통해 임시 테이블을 생성하는 것을 지양하자. (For 인덱스, I/O 작업 최소화)`

### table 칼럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. table 칼럼에 `<derived N> 또는 <union M, N>`으로 둘러싸인 이름이 명시되는 경우가 많은데, 이 테이블은 임시 테이블을 의미한다. 또한 <> 항상 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭한다.

![derived N의 의미](/이미지/image14.png)

1. 첫 번째 라인 테이블이 `<derived2>` 이므로, id =2인 단위 쿼리가 먼저 실행될 것이다. 그리고 그 결과가 파생 테이블로 주어진다.
2. 세 번째 라인을 보면, select_type 이 derived로 표시돼 있다. 즉 이 라인은 table 칼럼에 표시된 dept_emp 테이블을 읽어서 파생 테이블을 생성한다는 것을 알 수 있다.
3. 첫 번째 라인과 두 번째 라인은 같은 id 값을 가지고 있는 것으로 봐서 2개 테이블이 조인되는 쿼리라는 것을 알 수 있다. 이때, e 테이블보다 `<derived 2>`이 먼저 표시됐기 때문에, 해당 테이블이 드라이빙 테이블이 된다는 것을 알 수 있다.

### type 칼럼

쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다. 여기서 방식이라 함은 인덱스를 사용해 레코드를 읽었는지, 아니면 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 레코드를 읽었는지를 의미한다. : `쿼리 튜닝 시 반드시 체크!`

#### const

테이블의 레코드 건수와 관계없이 쿼리가 **프라이머리 키나 유니크 키 컬럼을 이용하는** WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const라고 한다.

#### eq_ref

eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다. 조인에서 처음 읽은 테이블의 칼럼값을, **그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때**를 가리켜 eq_ref라고 한다. 즉, 조인에서 조인 대상의 테이블의 행이 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.

```sql
SELECT * FROM dept_emp de, employees e
WHERE e.emp_no = de.emp_no AND de.dept_no = 'd005';
```

![eq_ref](/이미지/image15.png)

1. 먼저 de 를 읽는다. (de.dept_no = 'd005')
2. 이후, de.emp_no 와 일치하는 e.emp_no 를 불러온다. (e 의 프라이머리 키)

#### ref

ref 접근 방법은 eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다. : `반환되는 레코드가 반드시 1건이라는 보장이 없다!`

#### fulltext

fulltext 접근 방법은 MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.

```sql
CREATE TABLE employee_name(
    emp_no int NOT NULL,
    first_name varchar(14) NOT NULL,
    last_name varchar(16) NOT NULL,
    primary key (emp_no),
    fulltext key fx_name (first_name, first_name) WITH PARSER ngram
)
```

```sql
SELECT *
FROM employee_name
WHERE emp_no = 10001
    AND emp_no BETWEEN 1001 AND 10005
    AND MATCH(first_name, last_name) AGAINST('Facello', IN BOOLEAN MODE)
```

이 경우, 프라이머리 키 1건만 선택하면 되므로 `type=const` 이다.

```sql
SELECT *
FROM employee_name
WHERE
    emp_no BETWEEN 1001 AND 10005
    AND MATCH(first_name, last_name) AGAINST('Facello', IN BOOLEAN MODE)
```

이 경우에는 옵티마이저가 전문 검색 조건을 선택하였다. : `하지만 실제로는 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 많다고 한다!`

#### ref_or_null

이 접근 방법은 ref 접근 방법과 같은데, NULL 비교가 추가된 형태다.

#### unique_subquery

WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다. unique_subquery의 의미 그대로 **서브 쿼리에서 중복되지 않는 유니크한 값만 반환**할 때 이 접근 방법을 사용한다.

#### index_subquery

IN(subquery)에서 subquery가 중복된 값을 반환할 수도 있는 경우, 서브쿼리 결과의 중복된 값을 인덱스를 통해 제거할 수 있을때.

#### range

range는 우리가 익히 알고 있는 인덱스 레인지 스캔 형태의 접근 방법이다. range는 인덱스를 하나의 값이아니라 범위로 검색하는 경우를 의미한다. : `range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.`

#### index_merge

지금까지 설명한 다른 접근 방법과는 달리 index_merge 접근 방법은 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.

```sql
SELECT *
FROM employees
WHERE emp_no BETWEEN 10001 AND 11000
    OR first_name='Smith'
```

이 경우 각각의 인덱스(emp_no, first_name)에 대해서 **최적의 쿼리를 수행 후 결과를 병합**하기 때문에 index_merge 라는 typ e으로 표시된다.
: `여러 인덱스를 읽고, 병합하는 과정이 있기 떄문에 크게 효율적이지 않다고 한다!`

#### index

index 접근 방법은 **인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔**을 의미한다. range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것이 아니다.

index 접근 방법은 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다. 하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작다.

![index 접근 방법](/이미지/image16.png)

#### ALL

우리가 흔히 알고 있는 풀 테이블 스캔을 의미하는 접근 방법이다. 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환한다. 풀 테이블 스캔은 지금까지 설명한 접근 방법으로 처리할 수 없을 때 가장 마지막에 선택하는 **가장 비효율적인 방법이다.**

InnoDB도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 I/O를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어 들이는 기능을 제공한다. InnoDB에서는 이 기능을 `리드 어헤드(Read Ahead)`라고 하며, 한 번에 여러 페이지를 읽어서 처리할 수 있다. 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된(억지로 인덱스를 사용하게 튜닝된 쿼리)보다 더 나은 접근 방법이기도 하다.

일반적으로 index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경에서는 적합하지 않다. **테이블이 매우 작지 않다면 실제로 테이블에 데이터를 어느 정도 저장한 상태에서 쿼리의 성능을 확인해 보고 적용**하는 것이 좋다.

### possible_keys 칼럼

MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행한다. 그러나 possible_keys 칼럼에 있는 내용은 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐이다. : `즉, 인덱스 이름이 나열되었다고 해서 그 인덱스를 실제로 사용한다고 판단하지 말자!`

### key 칼럼

최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다. 그러므로 **쿼리를 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요**하다. key 칼럼에 표시되는 값이 PRIMARY인 경우에는 프라이머리 키를 사용한다는 의미이며, 그 이외의 값은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름이다.

실행 계획의 type 칼럼이 index_merge가 아닌 경우에는 반드시 테이블 하나당 하나의 인덱스만 이용할 수 있다.

- type이 ALL일 때와 같이 인덱스를 전혀 사용하지 못하면 key 칼럼은 NULL로 표시된다.

### key_len 칼럼

key_len 칼럼은 많은 사용자가 쉽게 무시하는 정보지만 사실은 매우 중요한 정보 중 하나다. 실제 업무에서 사용하는 테이블은 단일 칼럼으로만 만들어진 인덱스보다 다중 칼럼으로 만들어진 인덱스가 더 많다. 실행 계획의 key_len 칼럼의 값은 쿼리를 처리하기 위해 **다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 우리에게 알려준다**.

```sql
-- primary key (dept_no, emp_no) 로 구성된 경우.
SELECT * FROM dept_emp WHERE dept_no='d005';
```

![key_len](/이미지/image17.png)

- dept_no 칼럼이 char(4) 이며, utf8mb4 문자 집합을 사용하는 경우.
- utf8mb4 문자 하나당 4바이트의 공간을 확보한다. 따라서 key_len 의 값이 16바이트(4\*4 바이트)가 표시되었다.

```sql
SELECT * FROM dept_emp WHERE dept_no='d005' AND emp_no=10001;
```

- emp_no 칼럼은 INTEGER 타입이므로, 4바이트를 차지한다. 따라서 위의 경우에는 key_len 의 값이 20바이트로 표시된다.

### ref 칼럼

접근 방법이 ref면 참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다. 상숫값을 지정했다면 ref 칼럼의 값은 const, 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다.

가끔 쿼리의 실행 계획에서 ref 칼럼의 값이 func라고 표시될 때가 있다. 이는 "Function"의 줄임말로 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.

문자집합이 일치하지 않는 두 문자열 칼럼을 조인한다거나, 숫자 타입의 칼럼과 문자열 타입의 칼럼과 조인할 때, MySQL 서버가 내부적으로 값을 변환한다.
: `가능하다면 MySQL 서버가 이런 변환을 하지 않도록 조인 칼럼의 타입은 일치시키자!`

### rows 칼럼

MySQL 옵티마이저는 각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 최종적으로 하나의 실행 계획을 수립한다. 이때 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해서 비용을 산정한다.

MySQL 실행 계획의 rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다. 이 값은 각 스토리지 엔진별로 가지고 있는 **통계 정보**를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라 정확하지는 않다.
: `이는 쿼리의 결과 개수를 나타내는 것이 아닌, 비교 과정에서 필요한 행들을 나타내는 것임!`

```sql
SELECT * FROM dept_emp WHERE from_date >= '1985-01-01';
```

해당 쿼리의 실행 계획에서 rows 칼럼의 값은 331,143 레코드를 읽어야할 것으로 예측하였다. 따라서 from_date 인덱스를 이용하지 않고 풀 스캔을 선택하였다.

하지만, from_date 의 범위를 줄이게 된다면 rows 칼럼의 값이 줄어들게되고 이 결과로 from_date 인덱스를 선택하게 되었다.

### filtered 칼럼

옵티마이저는 각 테이블에서 일치하는 레코드 개수를 가능하면 정확히 파악해야 좀 더 효율적인 실행 계획을 수립할 수 있다. 실행 계획에서 rows 칼럼은 인덱스를 사용하는 조건에만 일치하는 레코드 건수를 예측한 것이다. 하지만 대부분 쿼리에서 WHERE 절에 사용되는 조건이 모두 인덱스를 사용할 수 있는 것은 아니다. 특히 **조인이 사용되는 경우에는 인덱스를 사용하지 못하는 조건에 일치하는 레코드 건수를 파악하는 것도 매우 중요하다.**

다음 예제 쿼리는 `e.first_name='Matt'` 조건은 인덱스를 사용할 수 있으며, `s.salary BETWEEN 50000 AND 60000` 조건이 인덱스를 사용할 수 있다.

```sql
SELECT *
FROM employees e, salaries s
WHERE e.first_name = 'Matt'
    AND e.hire_date BETWEEN '1990-01-01' AND '1991-01-01'
    AND s.emp_no = e.emp_no
    AND s.from_date BETWEEN '1990-01-01' AND '1991-01-01'
    AND s.salary BETWEEN 50000 AND 60000
```

![filtered](/이미지/image18.png)

employees 테이블에서 인덱스 조건에만 일치하는 레코드는 대략 232건이며, 이 중에서 16.03%만 인덱스를 사용하지 못하는 `e.hire_date BETWEEN '1990-01-01' AND '1991-01-01'` 조건에 일치한다는 것을 알 수 있다. **filtered 칼럼의 값은 필터링되고 남은 레코드의 비율을 의미한다.**

그래서 `employees` 테이블에서 `salaries` 테이블로 조인을 수행한 레코드 건수는 **대략 37(233 \* 0.1603)건 정도**였다는 것을 알 수 있다.
