## 인덱스

### 디스크 읽기 방식

**랜덤 I/O와 순차 I/O**

랜덤 I/O라는 표현은 하드 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미하는데, 사실 순차 I/O 또한 이 작업 과정은 같다.

Ex : 순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 요청하는 것에 비해 랜덤 I/O는 3번의 시스템 콜을 요청하게 되었다.

사실 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다. 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다. **여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선**하는 것을 의미한다.

### 인덱스란?

DBMS에서 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 **컬럼(또는 컬럼들)의 값과 해당 레코드가 저장된 주소**를 키와 값의 쌍으로 삼아 인덱스를 만들어 두는 것이다. 또한 최대한 빠르게 찾아갈 수 있게 인덱스도 **칼럼의 값을 주어진 순서로 미리 정렬해서 보관**한다.

SortedList 자료 구조는 데이터가 **저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 이어서 아주 빨리 원하는 값을 찾아올 수 있다**. : DBMS의 인덱스 또한 Insert, Update, Delete 처리가 느려진다. **대신 Select 의 처리가 매우 빨라진다.**

인덱스를 역할별로 구분해 본다면 **프라이머리 키(Primary key)와 보조 키(Secondary key)**로 구분할 수 있다.

- 프라미어미 키는 해당 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미. 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되며, NULL과 중복을 허용하지 않는다.

인덱스를 알고리즘 별로 구분할 경우, 대표적으로 **B-Tree 인덱스와 Hash 인덱스**로 구분할 수 있다.

- Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산하여 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 다만, 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위를 검색하는 경우 해시 인덱스를 사용할 수 없다.

데이터의 중복 허용 여부로 분류하면 유니크 인덱스(Unique)와 유니크하지 않은 인덱스(Non Unique)로 구분할 수 있다. 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.

: **유니크 인덱스에 대해 동등 조건(=)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더이상 탐색을 하지 않아도 된다는 것을 의미하기 때문에!**

### B-Tree 인덱스

B-Tree의 "B"는 "Binary(이진)"의 약자가 아니라 "Balanced"를 의미한다.

B-Tree는 칼럼의 원래 값을 변형시키지 않고, 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

**구조 및 특성**
B-Tree는 트리 구조의 최상위에 하나의 **루트 노드(Root node)**가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. 트리 구조의 가장 하위에 있는 노드를 **리프 노드(leaf node)**라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 **브랜치 노드(Branch node)**라고 한다. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, **인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값**을 가지고 있다.

<img src="../이미지/image4.png" alt="B-Tree" width="300">

(출처 : https://velog.io/@jsj3282/14.-B-Tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4)

인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 이씨 않고 임의의 순서로 저장돼 있다. 많은 사람들이 데이터 파일의 레코드는 INSERT된 순서대로 저장되는 것으로 생각하지만 그렇지 않다. : `레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT는 빈 공간을 채워야 공간을 활용할 수 있기 때문에!`

인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼람을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 **인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소**를 가진다.

<img src="../이미지/image5.png" alt="B-Tree" width="500">

InnoDB 스토리지 엔진을 사용하는 테이블에서는 프라이머리 키가 ROWID의 역할을 한다. 두 스토리지 엔진의 인덱스에서 가장 큰 차이점은 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방법에 있다. **MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.**

그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다. **즉, InnoDB 스토리지 엔진에서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 더 검색해야 한다.**
: `MyISAM은 인덱스를 통해 바로 데이터에 접근할 수 있는데, InnoDB는 왜 이 방식을 채택하는걸까?`

### B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다. B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.

리프노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되어야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이로인해 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.

**인덱스 추가로 인한 대략적인 비용 계산** : 레코드 추가 작업 비용 1 & 인덱스에 키를 추가하는 작업 비용 1.5

Ex : 일반적으로 테이블에 인덱스가 3개가 있다면, **비용 : 1 + 1.5 \* 3**

InnoDB 스토리지 엔진은 INSERT 시 발생하는 인덱스 추가 작업을 지연시켜 나중에 처리할 수 있다. (Unique & Primary Key는 제외).
: `가능하면 단순 인덱스를 거는게 삽입 성능을 조금이라도 증가시킬 수 있을 것 같다!`

**인덱스 키 삭제**

B-Tree의 키 값이 삭제되는 경우, 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 **삭제 마크만 하면 작업이 완료**된다. 이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다. 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 필요한 작업이다.

**인덱스 키 변경**

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다. **B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.** : `마찬가지로, 유니크 제약 조건이 있는 컬럼을 자주 수정하는 것은 좋지 않을듯하다!`

---

### 인덱스 키 검색

INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 **빠른 검색**을 위해서다. 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 **트리 탐색**이라고 한다.

인덱스 트리 탐색은 SELECT 뿐만 아니라 UPDATE 나 DELETE를 처리하기 위해 항상 레코드를 먼저 검색해야 할 경우에도 사용된다.

B-Tree 인덱스를 이용한 검색은 100% 일치 (=), 값의 앞부분만 일치하는 경우, 부등호 비교 조건(<, >)에서 사용할 수 있다.

```sql
SELECT * FROM users WHERE name = 'Alice';  -- 100% 일치
SELECT * FROM users WHERE name LIKE 'Ali%'; -- 앞부분 일치
SELECT * FROM users WHERE name > 'Bob';  -- 부등호 비교
```

인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키 값에 변형이 가해진 후 비교 되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다. 따라서 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의해야 한다.

**예시**

```sql
SELECT * FROM users WHERE age + 1 = 30;  -- (인덱스 사용 불가)
SELECT * FROM users WHERE age = 29;  -- Good!
```

InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다. InnoDB 테이블에서 지원하는 **레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후, 테이블의 레코드를 잠그는 방식**으록 구현돼 있다. 따라서 UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면, 불필요하게 많은 레코드를 잠근다. : `인덱스 설계가 중요함!`

---

### B-Tree 인덱스 사용에 영향을 미치는 요소

B-Tree 인덱스는 인덱스를 구성하는 **칼럼의 크기와 레코드의 건수**, 그리고 **유니크한 인덱스 키 값의 개수** 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

**인덱스 키 값의 크기**

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록(Block)이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 또한 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. 인덱스도 결국은 페이지 단위로 관리된다.

이진(Binary) 트리는 각 노드가 자식 노드를 2개만 가지는데, DBMS의 B-Tree가 이진 트리라면 인덱스 검색이 상당히 비효율적일 것이다.

: `자식 노드로 진행될때마다 절반씩 탐색 범위가 감소되므로! 만약 자식 노드가 3개라면, 탐색범위가 1/3 으로 줄어든다!`

일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. 그러면 MySQL의 B-Tree는 자식 노드를 몇 개까지 가지는지 궁금할 것이다. 그것은 바로 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다. : `InnoDB 스토리지 엔진의 페이지 기본 값은 16KB`

인덱스의 키가 16Byte 라고 가정하고, 자식 노드 주소를 평균 12Byte로 가정하자. 이 경우, 하나의 인덱스 페이지(16KB)에 몇 개의 키를 저장할 수 있을까?

: `(16 * 1024) / (16 + 12) = 585개.` 최종적으로 이 경우는 자식 노드를 585개 가질 수 있는 B-Tree가 되는 것이다.

인덱스 키 값을 2배 늘어난 32Byte로 가정하자. => `16 * 1024 / (32 + 12) = 372개.` 만약, 레코드 500개를 읽어야 한다면 전자는 인덱스 페이지 한번으로 **해결될 수도** 있지만, **후자는 최소 2번 이상 읽어야 한다.** 결국 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.

또한, 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의마한다. 이는 인덱스를 캐시해두는 InnoDB 버퍼 풀에 캐시해둘 수 있는 레코드 수가 줄어들게 되는 영향을 미치게된다.
