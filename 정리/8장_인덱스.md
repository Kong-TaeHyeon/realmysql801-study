## 인덱스

### 디스크 읽기 방식

**랜덤 I/O와 순차 I/O**

랜덤 I/O라는 표현은 하드 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미하는데, 사실 순차 I/O 또한 이 작업 과정은 같다.

Ex : 순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 요청하는 것에 비해 랜덤 I/O는 3번의 시스템 콜을 요청하게 되었다.

사실 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다. 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다. **여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선**하는 것을 의미한다.

### 인덱스란?

DBMS에서 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 **컬럼(또는 컬럼들)의 값과 해당 레코드가 저장된 주소**를 키와 값의 쌍으로 삼아 인덱스를 만들어 두는 것이다. 또한 최대한 빠르게 찾아갈 수 있게 인덱스도 **칼럼의 값을 주어진 순서로 미리 정렬해서 보관**한다.

SortedList 자료 구조는 데이터가 **저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 이어서 아주 빨리 원하는 값을 찾아올 수 있다**. : DBMS의 인덱스 또한 Insert, Update, Delete 처리가 느려진다. **대신 Select 의 처리가 매우 빨라진다.**

인덱스를 역할별로 구분해 본다면 **프라이머리 키(Primary key)와 보조 키(Secondary key)**로 구분할 수 있다.

- 프라미어미 키는 해당 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미. 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되며, NULL과 중복을 허용하지 않는다.

인덱스를 알고리즘 별로 구분할 경우, 대표적으로 **B-Tree 인덱스와 Hash 인덱스**로 구분할 수 있다.

- Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산하여 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 다만, 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위를 검색하는 경우 해시 인덱스를 사용할 수 없다.

데이터의 중복 허용 여부로 분류하면 유니크 인덱스(Unique)와 유니크하지 않은 인덱스(Non Unique)로 구분할 수 있다. 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.

: **유니크 인덱스에 대해 동등 조건(=)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더이상 탐색을 하지 않아도 된다는 것을 의미하기 때문에!**

### B-Tree 인덱스

B-Tree의 "B"는 "Binary(이진)"의 약자가 아니라 "Balanced"를 의미한다.

B-Tree는 칼럼의 원래 값을 변형시키지 않고, 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

**구조 및 특성**
