# 9장. 옵티마이저와 힌트

MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양하다. 이런 다양한 방법 중에서 **어떤 방법이 최적이고 최소의 비용이 소모될지 결정해야 한다.**

MySQL에서는 EXPLAIN이라는 명령으로 쿼리의 실행 계획을 확인할 수 있는데, 실행 계획에 표시되는 내용을 제대로 이해하기 위해선, MySQL 옵티마이저가 실행하는 최적화에 대해 어느 정도 지식을 갖추어야 한다.

## 개요

### 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다 : `SQL 파싱.`
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블을 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.

3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

두 번째 단계는 '최적화 및 실행 계획 수립' 단계이며, MySQL 서버의 **옵티마이저**에서 처리한다. 해당 단계가 완료되면 쿼리의 **실행 계획**이 만들어진다.

세 번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

### 옵티마이저의 종류

옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당한다. 옵티마저는 현재 대부분의 DBMS가 비용 기반 최적화(Cost-based optimizer, CBO)를 선택하고 있다.

- 규칙 기반 최적화(Cost-based optimizer)는 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.

- 비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.

## 기본 데이터 처리

MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다.

### 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다. MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우.
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우.
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 **조건 일치 레코드 건수가 너무 많은 경우**.

### 병렬 처리

하나의 쿼리를 여러 스레드가 작업을 나누어 처리할 수 있는 기능이 도입되었다. 해당 기능은 아무런 WHERE 조건 없이, 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.

### ORDER BY 처리

레코드 1~2건을 가져오는 쿼리를 제외하면, 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 데이터 웨어하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 아마도 레코드 정렬 요건은 대부분의 조회 쿼리에 포함돼 있을 것이다.

**인덱스 이용**

- 장점 : 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.
- 단점
  - INSERT, UPDATE, DELETE 작업 시, 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
  - 인덱스 때문에 디스크 공간이 더 많이 필요하다.
  - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.

**Filesort 이용**

- 장점
  - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.
  - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
- 단점 : 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

### 정렬 처리 방법

쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리된다. 일반적으로는 아래쪽에 있는 정렬 방법으로 갈수록 처리 속도는 떨어진다.

1. 인덱스를 사용한 정렬
2. 조인에서 드라이빙 테이블만 정렬
3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬

먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토할 것이다. 인덱스를 이용할 수 있다면 별도의 'Filesort' 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다. 하지만 **인덱스를 사용할 수 없다면** `WHERE` 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)할 것이다.

이때 정렬 대상 레코드를 최소화하기 위해 다음 2가지 방법 중 하나를 선택한다.

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행.
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행.

일반적으로 **조인이 수행되면서 레코드 건수와 레코드의 크기는 거의 배수로 불어나기 때문에** 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다.

### 인덱스를 이용한 정렬

인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.

또한 WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. : `DBMS가 인덱스 탐색을 하면서 자연스럽게 정렬이 될 수 있도록 하기 위함인듯 하다.`

인덱스를 이용해 정렬이 처리되는 경우에는 **실제 인덱스의 값이 정렬돼 있기 때문에** 인덱스의 순서대로 읽기만 하면 된다. 실제로 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지는 않는다.

조인이 네스티드-루프 방식으로 실행되기 때문에 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다. 하지만 조인이 사용된 쿼리의 실행 계획에 조인 버퍼(join buffer)가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 한다.

### 조인의 드라이빙 테이블만 정렬

일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어나고, 레코드 하나하나의 크기도 늘어난다. 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이 될 것이다.

이 방법으로 정렬이 처리되려면 조인에서 **첫 번째로 읽히는 테이블(드라이빙 테이블)의 컬럼만으로** `ORDER BY` 절을 작성해야 한다.

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no AND e.emp_no BETWEEN 10002 AND 10010
ORDER BY e.last_name;
```

- WHERE 절의 검색 조건(`e.emp_no BETWEEN 10002 AND 10010`)은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.
- salaries 의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다.

위의 이유로 employees 테이블이 드라이빙 테이블로 선택될 것이다.

이때 ORDER BY 절의 정렬 기준 칼럼이 드라이빙 테이블(employees)의 컬럼이므로, 옵티마이저는 먼저 정렬을 수행한 뒤 조인을 시도한다.

### 임시 테이블을 이용한 정렬

2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면, 임시 테이블이 필요할 수도 있다. 앞에서 살펴본 `조인의 드라이빙 테이블만 정렬`은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만, 임시 테이블을 사용하지 않는다. 하지만 그 외 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no AND e.emp_no BETWEEN 10002 AND 10010
ORDER BY s.salary;
```

위의 쿼리는 employees 테이블이 드라이빙 테이블로 사용되지만, ORDER BY 절에 있는 컬럼이 드리븐 테이블에 포함된 컬럼이기 때문에 정렬이 수행되기 전에 salary 테이블을 읽어야 한다. : `조인 결과를 임시 테이블에 저장 후, 다시 정렬하여 결과 반환.`

### 10장 이후, 다시 정리하기!
