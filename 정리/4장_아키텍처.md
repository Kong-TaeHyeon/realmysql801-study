# 4장. 아키텍처

## 4.1 MySQL 엔진 아키텍처

### MySQL의 전체 구조

MySQL 서버는 크게 **MySQL 엔진**과 **스토리지 엔진**으로 구분할 수 있다.

1. **MySQL 엔진**  
   클라이언트로부터의 접속 및 쿼리 요청을 처리하는 **커넥션 핸들러**와 **SQL 파서 및 전처리기**, 쿼리의 최적화 실행을 위한 **옵티마이저**.
2. **스토리지 엔진**  
   실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담한다. **MySQL 서버에서 MySQL 엔진은 하나**지만 **스토리지 엔진은 여러 개를 동시에 사용**할 수 있다.

**핸들러 API**  
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러(Handler) 요청이라 하고, 여기서 사용되는 API를 핸들러 API라고 한다. -> 해당 핸들러 API를 통해 얼마나 많은 작업이 있었는지 확인할 수 있다. : `스토리지와 엔진 사이의 작업을 확인할 수 있음!`

### **MySQL 스레딩 구조**

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동한다. 크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있다.

**포그라운드 스레드(클라이언트 스레드)**
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청을 처리하는 쿼리 문장을 처리한다.

데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.

- MyISAM 테이블은 디스크 쓰기 작업 까지 일반적으로 포그라운드 스레드가 처리.
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리. 이후 버퍼에서 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

**백그라운드 스레드**

**InnoDB**는 다음과 같이 여러 가지 작업이 백그라운드로 처리된다.

- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

: `(쓰기 작업) 디스크 작업에 반영될 내용은 이미 클라이언트 스레드(버퍼풀)에 있기 때문에, 클라이언트 스레드가 처리할 필요가 없이, 백그라운드 스레드에게 위임하는 것인거였다!` => 책에서도 이와 같이 쓰기 작업(Insert, Update, Delete)'로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다고 언급하고 있음! vs. **MyISAM**

`참고로, 읽기 작업과는 분리해서 생각해야할 것 같다! => 캐시/버퍼에 존재하지 않다면 해당 데이터를 반드시 읽어온 후, 클라이언트 스레드가 해당 내용을 전달해야하기 때문에.`

### 메모리 할당 및 사용 구조

**글로벌 메모리 영역**

일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 단, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와는 무관하며, **모든 스레드에 의해 공유된다**.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

**로컬 메모리 영역**

로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며, 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다. : `절대 공유되지 않는다. 마치 Stack!`

- 정렬 버퍼(Sort buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 스토리지 엔진의 처리 영역

MyISAM 이나 InnoDB와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도 MySQL의 처리 내용은 동일하다. **단순히 데이터를 읽고/쓰는 단계에서 처리의 차이만 있을 뿐**이다. 실질적인 복잡한 처리는 MySQL 엔진의 처리 영역(쿼리 실행기)에서 처리된다.

이러한 스토리지 엔진을 **플러그인 아키텍처**를 통해, 다양한 스토리지 엔진을 적용할 수 있다. (테이블마다).

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인간 통신은 할 수 없음.
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음

- 상호 의존 관계를 설정할 수 없어서 초기화가 어려움.

### 쿼리 실행 구조

**쿼리 파서**  
쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해, **트리 형태의 구조**로 만들어 내는 작업을 통해 기본 문법 오류를 발견한다.

**전처리기**  
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. -> 각 토큰마다 테이블 이름, 컬럼 이름, 내장 함수와 같은 개체 매핑.

**옵티마이저**  
사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당. : `성능 개선 포인트!`

**실행 엔진**  
실행 엔즌은 만들어진 **계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력**으로 연결하는 역할

**핸들러**  
실행 엔진의 요청을 따라 데이터를 디스크로 저장하고, 디스크로부터 읽어 오는 역할을 담당한다. -> 핸들러는 결국 스토리지 엔진을 의미하게 된다.

## 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다. `: 즉, 행 단위 잠금을 통해 동일 테이블에 대해서도 동시성 처리를 하면서도, 높은 속도를 제공할 수 있는거였다.`

### 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다. : `즉, 세컨더리 인덱스를 통해 접근하더라도 결국 프라이머리 키를 거치게 되는것 (이중 접근) -> 프라이머리 키를 통한 직접 접근이 굉장히 유리한듯!`

### 외래 키 지원

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM 이나 MEMORY 테이블에서는 사용할 수 없다.

- 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고
- 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요

결국, 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 주의가 필요하다.

### MVCC(Multi Version Concurrency Control)

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다. InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.

- **Multi Version** : 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다.

`INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울'); `  
`COMMIT;`

InnoDB 버퍼 풀(Global Memory)과 디스크에 저장된다.

`UPDATE member SET m_area='경기' WHERE m_id=12;`

UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값인 '경기'로 업데이트된다.

- 디스크는 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐수도 있음.
- Undo log에는 변경전 값인 '서울'이 아이디와 함께 복사된다.

`아직 COMMIT / ROLLBACK이 발생하지 않은 상태에서 다른 사용자가 m_id=12인 레코드를 조회하면 어디를 조회할까?`

격리 수준이 `READ_UNCOMMITTED`인 경우에는 **InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환**한다.

그 이상의 격리 수준인 경우에는 아직 커밋되지 않았기 때문에 이전 데이터 (언두 영역)를 반환한다.

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

격리 수준이 `SERIALIZABLE`이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 수준인 경우 INSERT와 연결되지 않은 **순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행**된다.

- 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

오랜 시간 동안 활성 상태인 트랜잭션이 있는 경우, 해당 트랜잭션으로부터 발생한 언두 로그를 일관된 읽기를 위해 게속 유지하고 있어야 한다. 이로인해 성능 저하의 원인이 될 수 있다. : `트랜잭션의 작업 단위를 최대한 줄이는게 좋겠군!`

### 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다. InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료한다. 이때, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다. : `롤백 처리를 할 내용이 적기 때문에`

동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 늘어나면, 데드락 감지 스레드가 느려진다. 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게 된다. : `innodb_ddeadlock_detect OFF & innodb_lock_wait_time 을 작게 설정하는 방법이 존재.`

### InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 여할도 같이 한다. : `일괄 작업을 통해, 랜덤한 디스크 작업의 횟수를 줄일 수 있음`

**버퍼 풀의 구조**  
InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 **페이지 크기의 조각**으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 LRU(Least Recently Used) 리스트와 플러시(Flush) 리스트, 그리고 프리(Free) 리스트라는 3개의 자료 구조를 관리한다.

**프리 리스트**는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지 목록. : `사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.`

**LRU 리스트** : 엄밀하게는 LRU + MRU(Most Recently Used) 리스트가 결합된 형태. `New 서브리스트`는 MRU, `Old 서브리스트`는 LRU로 구성.

InnoDB 스토리지 엔진에서 데이터를 찾는 과정은 대략 다음과 같다.

1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
   1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
   2. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
   3. 버퍼 풀에 이미 데이터 페이지가 있었다면, 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가.
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동.
4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여. 오래 사용되지 않으면, 버퍼 풀에서 제거된다.
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가. :` O(1) 으로 바로 접근 가능`

**플러시 리스트**는 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(이를 더티 페이지라고 함)의 변경 시점 기준의 페이지 목록을 관리한다. : `한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리된다.`  
데이터가 변경되면, 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.

**버퍼 풀과 리두 로그**  
InnoDB의 버퍼풀과 리두 로그는 매우 밀접한 관계를 갖고 있다.  
리두 로그 파일의 크기는 변하지 않은 채, 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 읽기(캐싱)기능만 향상시키는 것이다. : `리두 로그 파일의 전체 크기도 함께 늘려야한다.`

```
ex : 리두 로그 파일의 크기 100MB, 리두 로그 엔트리 크기 4KB, 데이터 페이지 16KB

총 엔트리 개수 : 100MB / 4KB = 25600개.


사용 가능한 더티 페이지 크기 : 25600 * 16KB = 400MB
```

### 언두 로그

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(Insert, Update, Delete)로 변경되기 이전 버전의 데이터를 별도로 백업한다. 이렇게 백업된 데이터를 언두 로그(Undo Log)라고 한다.

- **트랜잭션 보장**  
  트랜잭션 롤백 시, 언두 로그에 백업해둔 데이터를 이용해 복구.

- **격리 수준 보장**  
  특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면, 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.

### 어댑티브 해시 인덱스

B-Tree 인덱스에서 특정 값을 찾기 위해서 B-Tree의 루트 노드를 거쳐서 브랜치 노드, 그리고 최종적으로 리프 노드까지 찾아가야 원하는 레코드를 읽을 수 있다. 이러한 **리프 노드까지 찾아가는 비용을 없애기 위해 도입된 기능**이 어댑티브 해시 인덱스이다.

해시 인덱스는 '인덱스 키 값'과 해당 인덱스 키 값이 저장된 '데이터 페이지 주소'의 쌍으로 관리되는데, 인덱스 키 값은 'B-Tree 인덱스의 고유 번호'와 B-Tree 인덱스의 실제 키 값' 조합으로 생성된다. : `특정 키 값이 어느 인덱스에 속한 것인지 구분해야 하기 때문`
